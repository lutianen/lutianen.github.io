[{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"深入剖析 Golang 网络编程之 Netpoll，主要涉及 Linux 环境下的 Epoll 初始化、 Go 网络编程基本流程（Listen、Accept、Read、Write）以及netpoll 执行流程 本文所涉及的源码版本：v1.22.3 ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:0:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"I. 基础概念 网络编程，是允许不同计算机上的程序通过网络通信的开发过程，涉及多种协议（HTTP、TCP/IP等）以及不同编程语言的应用。 ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:1:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"同步、异步、并发模型 IO 模型 读写操作和阻塞阶段 阻塞 IO 程序阻塞于读写函数 IO 复用 程序阻塞于 IO 复用系统调用，但可同时监听多个 IO 事件；对 IO 本身的读写操作是非阻塞的 SIGIO 信号 信号触发读写就绪事件，用户程序执行读写操作；程序本身没有阻塞阶段 异步 IO 内核执行读写操作并触发读写完成事件；程序没有阻塞阶段 主要用于区分内核向应用程序通知的是何种 IO 事件（就绪事件 or 完成事件），以及由谁来完成 IO 读写（应用程序 or 内核） IO模型中的同步 同步 IO 模型，指的是应用程序发起 IO 操作后，必须等待 IO 操作完成后才能继续执行后续的操作，即 IO 操作的结果需要立即返回给应用程序；在此期间，应用程序处于阻塞状态，无法做其他操作。 优点：编程模型简单 缺点：效率较低（应用程序的执行速度被 IO 操作所限制） 对于操作系统内核来说，同步 IO 操作是指在内核处理 IO 请求时需要等待 IO 模型中的异步 异步 IO 模型，指的是应用程序发起 IO 操作后，无须等待 IO 操作完成，可以立即进行后续的操作；在此期间，操作系统负责把 IO 操作的结果返回给应用程序； 优点：可以充分利用系统资源，提高 IO 操作的效率 缺点：编程模型相对复杂 对于操作系统内核来说，异步 IO 操作指的是，在内核处理 IO 请求时无需等待，立即返回 并发模式 并发模式，指的是 I/O 处理单元和多个逻辑单元之间协调完成任务的方法 ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:1:1","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"Linux Epoll epoll 在内核里使用红黑树(Red-black tree)来跟踪进程所有待检测的文件描述字 fd，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里（红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)） epoll 使用事件驱动的机制，在内核里维护了一个链表(List)来记录就绪事件。 当某个 socket 有事件发生时，内核通过回调函数将其加入到这个就绪事件列表中。 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率 两种触发模式 Level trigger：服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束 Edge trigger：服务器端只会从 epoll_wait 中苏醒一次 事件宏 EPOLLIN 表示对应的文件描述符可读（包括对端 socket 正常关闭） EPOLLOUT 表示对应的文件描述符可写 EPOLLPRI 表示对应的文件描述符有紧急的数据可读（带外数据） EPOLLERR 表示对应的文件描述符发生错误 EPOLLHUP 表示对应的文件描述符被挂断 EPOLLET 将 EPOLL 设为边缘触发模式（默认电平触发） EPOLLONESHOT 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到内核中的事件注册表中 ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:1:2","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"II. 应用示例 package main import \"net\" func main() { l, _ := net.Listen(\"tcp\", \"127.0.0.1:2333\") for { conn, _ := l.Accept() go func() { defer conn.Close() buf := make([]byte, 4096) _, _ = conn.Read(buf) conn.Write(buf) }() } } ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:2:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"III. 相关数据结构 // src/net/fd_fake.go // Network file descriptor. type netFD struct { pfd poll.FD // immutable until Close family int sotype int isConnected bool // handshake completed or use of association with peer net string laddr Addr raddr Addr // The only networking available in WASI preview 1 is the ability to // sock_accept on a pre-opened socket, and then fd_read, fd_write, // fd_close, and sock_shutdown on the resulting connection. We // intercept applicable netFD calls on this instance, and then pass // the remainder of the netFD calls to fakeNetFD. *fakeNetFD } // poll.FD`: `src/internal/poll/fd_unix.go // FD is a file descriptor. The net and os packages use this type as a // field of a larger type representing a network connection or OS file. type FD struct { // Lock sysfd and serialize access to Read and Write methods. fdmu fdMutex // System file descriptor. Immutable until Close. Sysfd int // Platform dependent state of the file descriptor. SysFile // I/O poller. pd pollDesc // Semaphore signaled when file is closed. csema uint32 // Non-zero if this file has been set to blocking mode. isBlocking uint32 // Whether this is a streaming descriptor, as opposed to a // packet-based descriptor like a UDP socket. Immutable. IsStream bool // Whether a zero byte read indicates EOF. This is false for a // message based socket connection. ZeroReadIsEOF bool // Whether this is a file rather than a network socket. isFile bool } // Addr represents a network end point address. // // The two methods [Addr.Network] and [Addr.String] conventionally return strings // that can be passed as the arguments to [Dial], but the exact form // and meaning of the strings is up to the implementation. type Addr interface { Network() string // name of the network (for example, \"tcp\", \"udp\") String() string // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\") } // fdMutex is a specialized synchronization primitive that manages // lifetime of an fd and serializes access to Read, Write and Close // methods on FD. type fdMutex struct { state uint64 rsema uint32 wsema uint32 } type SysFile struct { // Writev cache. iovecs *[]syscall.Iovec } type pollDesc struct { runtimeCtx uintptr } 通过源码可以看到，Golang 网络编程涉及到的 netFD, poll.FD, Addr, SysFile 以及 pollDesc 之间的关系如下： fdmu 是为了保证对同一个文件的读、写操作能分别被序列化 Sysfd 就是操作系统中 syscall 返回的 fd 值 pd，pollDesc I/O poller，是 Go 对 poll 过程的一个抽象，所有平台的抽象都是一样的 csema，当文件被关闭时会被触发 isBlocking 表明 FD 是否为 blocking 模式 IsStream 标志该 FD 是否是流式，与流式相反的是基于 packet 的，即 UDP socket ZeroReadIsEOF，当连接读到 0 长度时，用来区分是否代表 EOF. 如果是基于 packet 的 socket 连接，则始终是 false isFile 标志该 FD 是否代表文件，还是网络连接 netFD 结构中包含一个 poll.FD 类型的成员 pfd，以及 Addr 接口类型的 laddr 和 raddr poll.FD 结构含有 SysFile 和 pollDesc 类型的成员，以及 fdMutex 类型的 fdmu ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:3:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"IV. TCP 网络编程基本流程 本部分涉及众多函数调用，为了描述清晰，采用了图的形式，其中，每一块第一行表示该块所表示的函数名称，其他部分表示该函数中关键函数调用。 ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:4:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"创建 TCP socket 并监听: net.Listen NOTE 需要注意的是，在执行 net.(*netFD).listenStream 之前，由于 maxListenerBacklog 函数调用了 open(\"/proc/sys/net/core/somaxconn\")，则会导致 epoll 底层红黑树的提前创建: runtime.netpollinit -\u003e syscall.EpollCreate1 -\u003e Syscall6(SYS_EPOLL_CREATE1, uintptr(flags), 0, 0, 0, 0, 0). 另外，当启用 Timer 时，也存在提前初始化 netpoll 的可能，原因： Timers rely on the network poller time.NewTimer -\u003e runtime.startTimer -\u003e runtime.addtimer -\u003e runtime.doaddtimer -\u003e netpollGenericInit() // doaddtimer adds t to the current P's heap. // The caller must have locked the timers for pp. func doaddtimer(pp *p, t *timer) { // Timers rely on the network poller, so make sure the poller // has started. if netpollInited.Load() == 0 { netpollGenericInit() } ... } ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:4:1","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"获取 TCP 连接: net.(*TCPListener).Accept ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:4:2","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"TCP 连接读数据: net.(*TCPConn).Read ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:4:3","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"TCP 连接写数据: net.(*TCPConn).Write ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:4:4","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"V. netpoll 执行流程: netpoll 在调度和 GC 的关键点上都会检查一次 netpoll，确定是否存在 ready 状态的 FD： startTheWorldWithSema // reason is the same STW reason passed to stopTheWorld. start is the start // time returned by stopTheWorld. // // now is the current time; prefer to pass 0 to capture a fresh timestamp. // // stattTheWorldWithSema returns now. func startTheWorldWithSema(now int64, w worldStop) int64 { assertWorldStopped() mp := acquirem() // disable preemption because it can be holding p in a local var if netpollinited() { list, delta := netpoll(0) // non-blocking injectglist(\u0026list) netpollAdjustWaiters(delta) } lock(\u0026sched.lock) procs := gomaxprocs if newprocs != 0 { procs = newprocs newprocs = 0 } p1 := procresize(procs) sched.gcwaiting.Store(false) if sched.sysmonwait.Load() { sched.sysmonwait.Store(false) notewakeup(\u0026sched.sysmonnote) } unlock(\u0026sched.lock) worldStarted() ... } findrunnable // Finds a runnable goroutine to execute. // Tries to steal from other P's, get g from local or global queue, poll network. // tryWakeP indicates that the returned goroutine is not normal (GC worker, trace // reader) so the caller should try to wake a P. func findRunnable() (gp *g, inheritTime, tryWakeP bool) { ... // Poll network until next timer. if netpollinited() \u0026\u0026 (netpollAnyWaiters() || pollUntil != 0) \u0026\u0026 sched.lastpoll.Swap(0) != 0 { sched.pollUntil.Store(pollUntil) if mp.p != 0 { throw(\"findrunnable: netpoll with p\") } if mp.spinning { throw(\"findrunnable: netpoll with spinning\") } delay := int64(-1) if pollUntil != 0 { if now == 0 { now = nanotime() } delay = pollUntil - now if delay \u003c 0 { delay = 0 } } if faketime != 0 { // When using fake time, just poll. delay = 0 } list, delta := netpoll(delay) // block until new work is available ... } ... } pollWork // pollWork reports whether there is non-background work this P could // be doing. This is a fairly lightweight check to be used for // background work loops, like idle GC. It checks a subset of the // conditions checked by the actual scheduler. func pollWork() bool { if sched.runqsize != 0 { return true } p := getg().m.p.ptr() if !runqempty(p) { return true } if netpollinited() \u0026\u0026 netpollAnyWaiters() \u0026\u0026 sched.lastpoll.Load() != 0 { if list, delta := netpoll(0); !list.empty() { injectglist(\u0026list) netpollAdjustWaiters(delta) return true } } return false } sysmon // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { ... lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // poll network if not polled for more than 10ms lastpoll := sched.lastpoll.Load() if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u003c now { sched.lastpoll.CompareAndSwap(lastpoll, now) list, delta := netpoll(0) // non-blocking - returns list of goroutines if !list.empty() { // Need to decrement number of idle locked M's // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P's but before it starts M's to run the P's, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M's // and reports deadlock. incidlelocked(-1) injectglist(\u0026list) incidlelocked(1) netpollAdjustWaiters(delta) } } ... } 根据 ready 的事件时 Read 或 Write，分别从 poolDesc 的 rg、wg 上获取该唤醒的 goroutine. 然后将已经 ready 的 goroutine push 到 toRun 链表，并且 toRun 链表最终会从 netpoll() 返回，通过 injectglist 进入全局队列. 相当于每次调度循环都要执行 netpoll，检查频率还是比较高的 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // delay \u003c 0: blocks indefinitely // delay == 0: does not block, just polls // delay \u003e 0: block for up to that many nanoseconds func netpoll(delay int64) (gList, int32) { if epfd == -1 { return gList{}, 0 } var waitms int32 if delay \u003c 0 { waitms = -1 } else if ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:5:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"VI. 总结 Golang 通过对 Linux 内核提供的 epoll 实现进行封装，实现了同步编程异步执行的效果，其核心数据结构是 netFD，并将 Sysfd 与 pollDesc 结构绑定。 当某个 netFD 产生 EAGAIN 错误时，则当前 Goroutine 将会被存储到其对应的 pollDesc 中，同时 Goroutine 会 gopark()，直至这个 netFD 再次发生读写事件，会将此 Goroutine 设置为 ready 并放入 toRun 队列等待重新运行，而底层事件通知机制就是 epoll. Golang 中 netpoll 的创建与初始化的可能来源：Timer、读文件、TCP Listen. 如下的调度和 GC 关键函数 startTheWorldWithSema、findrunnable、pollWork、sysmon 都会进行 netpoll 执行流程，检查是否存在 ready 状态的 FD. ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:6:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"VII. Reference runtime/netpoll.go runtime/netpoll_epoll.go runtime/proc.go net/fd_unix.go internal/poll/fd_poll_runtime.go internal/poll/fd_unix.go ","date":"2024-05-08","objectID":"/netpoll-of-network-program-for-golang/:7:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Netpoll of Network Program for Golang","uri":"/netpoll-of-network-program-for-golang/"},{"categories":["Golang","Profile","Optimize"],"content":"Golang 常见的性能剖析 (Profile) 与优化 (Optimize) ","date":"2024-04-20","objectID":"/go-profile/:0:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"I. Profile 在进行 API 压测、全链路压测、线上生产环境被高峰流量打爆的过程中随时可能发生故障等问题，例如： CPU 占用过高，超过 90%； 内存爆掉，OOM(Out of memory)； Goroutine 数量过多，80W； 线程数超高； 延迟过高； 在发生以上故障时，一般需要结合 pprof 寻找故障原因，并根据不同的情况选择不同的方案； 线上一定要具有开启 pprof 的能力，如果考虑安全性，也要具有通过配置开启的能力； ","date":"2024-04-20","objectID":"/go-profile/:1:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"压测时需要关注的服务指标 Request rate: The number of service requests per second. Errors: The number of request that failed. Duration: The time for requests to complete. Goroutine / Thread 数量: 如果 Goroutine 数量很多，需要关注这些 Goroutine 的执行情况. GC 频率 gctrace 的内容: GC 的 STW 时间 还有一些其他 Memstats 相关的其他指标，可以参考 Prometheus. ","date":"2024-04-20","objectID":"/go-profile/:1:1","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"压测手段 wrk: a HTTP benchmarking tool wrk2: a HTTP benchmarking tool based mostly on wrk HEY: a tiny program that sends some load to a web application. Vegate: a versatile HTTP load testing tool built out of a need to drill HTTP services with a constant request rate. h2load: HTTP/2 benchmarking tool ghz: gRPC benchmarking and load testing tool ","date":"2024-04-20","objectID":"/go-profile/:1:2","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"pprof 应用实例 package main import ( \"net/http\" _ \"net/http/pprof\" ) var quit chan struct{} = make(chan struct{}) func f() { \u003c- quit } func main() { go func() { http.ListenAndServe(\":8080\", nil) }() for i := 0; i \u003c 10000; i++ { go f() } for {} // Test } go tool pprof -http=:9999 localhost:8080/debug/pprof/heap 注意事项 测试代码中引入 net/http/pprof 包： _ \"net/http/pprof\" 单独启动一个 Goroutine 开启监听(端口自定，例如这里是 8080)：go func() { http.ListenAndServe(\":8080\", nil) }() $ go tool pprof -http=:9999 localhost:8080/debug/pprof/heap ","date":"2024-04-20","objectID":"/go-profile/:1:3","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"II. Optimize ","date":"2024-04-20","objectID":"/go-profile/:2:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"优化方向 在分析上图的应用程序运行过程，可以发现进行程序优化时，一般从可以从以下方面入手： 应用层优化: 主要指的是逻辑优化、内存使用优化、CPU 使用优化、阻塞优化等，并且本层优化效果可能优于底层优化； 底层优化：GC优化、Go 标准库优化、Go runtime 优化等 ","date":"2024-04-20","objectID":"/go-profile/:2:1","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"基本优化流程 外部依赖：在监控系统中查看是否存在问题，例如依赖的上游服务 (DB/redis/MQ) 延迟过高； CPU 占用：通过查看 CPU profile 检查是否存在问题，优化占用 CPU 较多的部分逻辑； 内存占用：看 Prometheus，内存 RSS / Goroutine 数量 / Goroutine 栈占用 –» 如果 Goroutine 数量不多，则重点关注 heap profile 中的 inuse –» 定时任务类需要看 alloc Goroutine 数量过多 –» 从 profile 网页进去看看 Goroutine 的执行情况（在干什么？） –» 检查死锁、阻塞等问题 –» 个别不在意延迟的选择第三方库优化 ","date":"2024-04-20","objectID":"/go-profile/:2:2","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"常见优化场景 字符串拼接 package main import ( \"fmt\" \"testing\" ) func BenchmarkConcat0(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += \"userid : \" + \"1\" str += \"localtion : \" + \"ab\" } } func BenchmarkConcat1(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += fmt.Sprintf(\"userid : %v\", \"1\") str += fmt.Sprintf(\"localtion : %v\", \"ab\") } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench0 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcat0-16 35702518 32.86 ns/op 24 B/op 1 allocs/op BenchmarkConcat1-16 8105732 140.9 ns/op 56 B/op 3 allocs/op PASS ok github.com/lutianen/go-test/bench0 2.506s 逃逸分析 用户声明的对象，被放在栈上还是堆上？ 可以通过编译器的 escape analysis 来决定 go build -gcflags=\"-m\" xxx.go package main func main() { var sl = make([]int, 1024) println(sl[0]) var sl0 = make([]int, 10240) println(sl0[0]) } $ go build -gcflags=\"-m\" main.go # command-line-arguments ./main.go:3:6: can inline main ./main.go:4:15: make([]int, 1024) does not escape ./main.go:7:16: make([]int, 10240) escapes to heap TODO: 各种逃逸分析的可能性有哪些？ Trasval 2-D Matrix package bench1 import \"testing\" func BenchmarkHorizontal(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[x][y] = 1 } } } } func BenchmarkVertical(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[y][x] = 1 } } } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench1 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkHorizontal-16 15 71020410 ns/op 54629717 B/op 666 allocs/op BenchmarkVertical-16 1 1059649022 ns/op 819445856 B/op 10002 allocs/op PASS ok github.com/lutianen/go-test/bench1 3.676s Zero Garbage / Allocation Zero Grabage 一般指的是通过利用 sync.Pool 将堆分配完全消灭的优化技术。 例如，在 http router 框架 fasthttp 中应用较多. False Sharing CPU 运行过程中修改数据是一个 cache line为单位，当两个变量A/B满足以下条件： 在内存中相邻 并发修改频繁 那么，当 CPU0 修改变量 A 时，会导致 CPU1 中的变量 B 缓存失效。 解决方法，在定义数据结构中，填充一些 padding 用以满足该数据结构正好是 cache line 的整数倍； type NoPad struct { x uint64 y uint64 } type WithPad struct { x uint64 _ [6]uint64 y uint64 } 查看 cache line 大小：cat /sys/devices/system/cpu/cpu\u003ccore-num\u003e/cache/index0/coherency_line_size 降低外部命令调用频次 优化前： func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := exec.Command(\"uuidgen\").Output() // Use exec.Command wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, string(uuid)) } 优化后： import uuid \"github.com/satori/go.uuid\" func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := uuid.NewV4() // Replace exec.Command with existing library wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, uuid.String()) } 总结： 线上使用 exec 命令是非常危险的 采用第三方库代替外部命令 阻塞导致高延迟 锁阻塞 var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() defer mtx.Unlock() buf := data[\"hint\"] time.Sleep(time.Millisecond * 10) // 临界区内的慢操作 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 减小临界区 - 优化后： var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() buf := data[\"hint\"] mtx.Unlock() time.Sleep(time.Millisecond * 10) // 慢操作放置于临界区之外 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 在后端系统开发中，锁瓶颈是较常见的问题，例如文件锁 双 Buffer 完全干掉锁阻塞 使用双 Buffer / RCU 完全消除读阻塞：全量更新，直接替换原 config func updateConfig() { var newConfig = \u0026MyConfig { WhiteList: make(map[int]struct{}), } // Do a lot of compulation ","date":"2024-04-20","objectID":"/go-profile/:2:3","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"III. Coutinuous Profiling 压测是一个蹲点行为，然而真实场景并不美好，它们通常是难以发现的偶发问题： 该到吃饭的时候，CPU 使用尖刺 凌晨四点半，系统发生 OOM 刚睡着的时候，Goroutine 数量爆炸 产品被部署到客户那里，想登陆客户的环境并不方便 此时 Coutinuout Profiling 就派上用场了. 自省式的 Profile Dumper，可以根据 CPU 利用率、Memory 利用率、Goroutine 数量等多个指标检测系统，设置定时周期进行检测，当发现某个指标异常时，自动 Dump file. ","date":"2024-04-20","objectID":"/go-profile/:3:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"IV. Summary _pad 优化，针对多个线程更新同一个结构体内不同的字段场景有效，而针对一个线程同时更新整个结构体的场景意义不大； 第三方接口出现问题，如何保护自己的服务？ 对外部调用必须有超时 ==\u003e 熔断 goroutine 初始化栈空间为 2KB，最大 1GB，那么 heap 为什么不爆栈？ 在 Go 语言中，goroutine 和 heap 使用单独的内存空间：Goroutine 有自己的堆栈空间，用于存储局部变量、函数帧和其他运行时信息；heap 则是一个共享内存空间，用于存储动态分配的对象，例如 slice、map 和 strings。 当 Goroutine 需要分配的内存多于起堆栈上的可用内存时，它将自动从 stack 中分配内存，采用的是 stack 分配机制完成，运行 goroutine 分配任何数量的内存，而不用担心 stack 空间耗尽； 除了堆分配之外，goroutine 还可以使用一种称为堆栈复制的技术来在它们之间共享数据，堆栈复制比堆分配更有效，但它只能用于共享足够小以适合堆栈的数据。 ","date":"2024-04-20","objectID":"/go-profile/:4:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"V. Reference Benchmarks Game Go Web Frame Benchmarks Go HTTP Router Benchmark Web 场景跨语言性能对比 《Systems Performance》 Dave 分享的 High Performance Go Workshop go-perfbook: best practices for writing high-performance Go code Delve What is Continuous Profiling? Google-Wide Profiling: A Continuous Profiling Infrastructure for Data Centers ","date":"2024-04-20","objectID":"/go-profile/:5:0","tags":["Golang","Profile","Optimize"],"title":"Profile and Optimize for Go","uri":"/go-profile/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"各种流行的 Go Linter 介绍，例如 Gocyclo、bodyclose、sqlrows、GolangCI-Lint、reviewdog等 ","date":"2024-04-19","objectID":"/linter-go/:0:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"一、 Gocyclo Gocyclo，函数圈复杂度(cyclomatic complexities)计算工具，计算方法： 1 is the base complexity of a function +1 for each if, for, case, \u0026\u0026 or || NOTE 在 Go 语言中，由于 if err != nil 的特殊情况存在，因此，当圈复杂度超过 15 时，则表明函数较复杂； 其他语言中圈复杂度阈值一般设置为 10； switch 中的 default 并不会增加函数的圈复杂度； ","date":"2024-04-19","objectID":"/linter-go/:1:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Install gocyclo commond tool go install github.com/fzipp/gocyclo/cmd/gocyclo@latest ","date":"2024-04-19","objectID":"/linter-go/:1:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Usage Calculate cyclomatic complexities of Go functions. Usage: gocyclo [flags] \u003cGo file or directory\u003e ... Flags: -over N show functions with complexity \u003e N only and return exit code 1 if the set is non-empty -top N show the top N most complex functions only -avg, -avg-short show the average complexity over all functions; the short option prints the value without a label -ignore REGEX exclude files matching the given regular expression The output fields for each line are: \u003ccomplexity\u003e \u003cpackage\u003e \u003cfunction\u003e \u003cfile:line:column\u003e ","date":"2024-04-19","objectID":"/linter-go/:1:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Example package main import ( \"fmt\" \"strconv\" ) func main() { var a = 10 if a == 10 { f() } else { fmt.Printf(\"%s\", strconv.Itoa(a)) } switch a{ case 10: fmt.Println(a) default: fmt.Println(\"default\") } } func f() { a := 10 b := 12 if a != b { // do something fmt.Println(\"a != b\") } } $ gocyclo gocyclo-test/main.go 3 main main gocyclo-test/main.go:8:1 2 main f gocyclo-test/main.go:24:1 ","date":"2024-04-19","objectID":"/linter-go/:1:3","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"二、bodyclose bodyclose 是检查 res.Body 是否被正确关闭的静态检查工具； ","date":"2024-04-19","objectID":"/linter-go/:2:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Install go install github.com/timakin/bodyclose ","date":"2024-04-19","objectID":"/linter-go/:2:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Usage 这里借用 GolangCI-Linter 的方式使用 bodyclose package Kyden import ( \"fmt\" \"io\" \"net/http\" ) func f() error{ resp, err := http.Get(\"http://example.com/\") if err != nil { return err } // defer resp.Body.Close() body, err := io.ReadAll(resp.Body) fmt.Println(body) return nil } $ golangci-lint run --disable-all -E bodyclose main.go main.go:10:26: response body must be closed (bodyclose) resp, err := http.Get(\"http://example.com/\") Tip: 避免使用 http 库中 body 忘记 close 的更优方案是：对 Go 官方提供的 http 进行封装，使 caller 不用显示调用 close 函数. ","date":"2024-04-19","objectID":"/linter-go/:2:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"三、sqlrows sqlrows is a static code analyzer which helps uncover bugs by reporting a diagnostic for mistakes of sql.Rows usage. ","date":"2024-04-19","objectID":"/linter-go/:3:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Install go install github.com/gostaticanalysis/sqlrows ","date":"2024-04-19","objectID":"/linter-go/:3:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Usage package sqlrowstest_test import ( \"context\" \"database/sql\" ) func f(ctx context.Context, db *sql.DB) (interface{}, error) { rows, err := db.QueryContext(ctx, \"SELECT * FROM users\") defer rows.Close() if err != nil { return nil, err } // defer rows.Close() for rows.Next() { err = rows.Scan() if err != nil { return nil, err } } return nil, nil } go vet -vettool=$(which sqlrows) main.go (base) # command-line-arguments ./main.go:10:11: using rows before checking for errors go vet -vettool=$(which sqlrows) main.go (base) # command-line-arguments ./main.go:9:33: rows.Close must be called ","date":"2024-04-19","objectID":"/linter-go/:3:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"四、GolangCI-Lint golangci-lint is a fast Go linters runner. It runs linters in parallel, uses caching, supports YAML configuration, integrates with all major IDEs, and includes over a hundred linters. 生产级静态分析工具 ","date":"2024-04-19","objectID":"/linter-go/:4:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"本地安装 注意版本：v1.57.2 # binary will be $(go env GOPATH)/bin/golangci-lint curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.57.2 golangci-lint --version ","date":"2024-04-19","objectID":"/linter-go/:4:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Usage 在不进行任何配置的情况下，GolangCI-Lint 将默认采用启动以下 Linters: errcheck, gosimple, govet, ineffassign, staticcheck, unused 还可以通过传递 -E/--enable 参数来启动 Linter，传递 -D/--disable 来禁用 Linter golangci-lint run --disable-all -E errcheck ","date":"2024-04-19","objectID":"/linter-go/:4:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Visual Studio Code 集成 VSCode配置 settings.json \"go.lintTool\": \"golangci-lint\", \"go.lintFlags\": [ \"--fast\" // Using it in an editor without --fast can freeze your editor. ] Golangci-lint automatically discovers .golangci.yml config for edited file: Don’t need to configure it in VS Code settings. 更多详细信息，请参考官方文档 ","date":"2024-04-19","objectID":"/linter-go/:4:3","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"五、reviewdog A code review dog who keeps your codebase healthy. 将常用的 Linter 集成在 CI 上线流程中，可以保证项目代码质量的下限 ","date":"2024-04-19","objectID":"/linter-go/:5:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"六、Reference Cyclomatic complexity Gocyclo bodyclose sqlrows GolangCI-Lint static analysis reviewdog ","date":"2024-04-19","objectID":"/linter-go/:6:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"Linter for Go","uri":"/linter-go/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"分享一个好看的 Typora 主题 ","date":"2024-04-18","objectID":"/typora-theme/:0:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"效果 本 Typora 软件主题是在 Purple 之上修改而来，具体效果如下： ","date":"2024-04-18","objectID":"/typora-theme/:1:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Source 由于实现源码太长，给出下载连接：Kyden.css ","date":"2024-04-18","objectID":"/typora-theme/:2:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Reference Typora Purple ","date":"2024-04-18","objectID":"/typora-theme/:3:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/typora-theme/"},{"categories":[],"content":"Kyden 起源 奥地利心理学家阿德勒曾说，幸福的人用童年治愈一生，不幸的人用一生治愈童年。 本人来自于华中地区的小农村，毋庸置疑拥有一个非常轻松加愉快的童年，而“纸鸢飞舞”属于童年中的记忆深刻的事物，故以此为作为昵称。 Kyden (纸鸢飞舞，鸢舞) 来自 “kite” 和“dance” 组合的变体 “KiteDance”。 ","date":"2024-04-18","objectID":"/about/:1:0","tags":[],"title":"About Kyden (鸢舞)","uri":"/about/"},{"categories":[],"content":"Special Thanks Thanks to the authors of following resources included in the theme: Hugo LoveIt Gitalk ","date":"2024-04-18","objectID":"/about/:2:0","tags":[],"title":"About Kyden (鸢舞)","uri":"/about/"},{"categories":["Linux","Software"],"content":"详细介绍日常使用 Arch Linux 时的各种问题与解决方案，例如 Arch 安装、常用软件推荐、系统优化等 ","date":"2024-04-17","objectID":"/archlinuxnote/:0:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"零、Install Arch Download Arch Linux ISO archlinux-x86_64.iso U 盘 ventoy 准备 略 选择 Arch Linux install medium (x86_64, UEFI) 启动安装环境 进入 root@archiso 后，需要设置互联网，推荐使用网线连接 检查网络接口是否已经启用 ip link 2: enp0s3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 ... 尖括号内的“UP”，表示接口已经启用，否则使用以下命令：ip link set enp0s3 up 请使用 ping 命令测试网络: ping www.baidu.com 更新系统时钟: 在互联网连接之后，systemd-timesyncd 服务将自动校准系统时间，便于安装软件包时验证签名 timedatectl 分区设置 mkfs.ext4 /dev/nvme1n1p7 #用作根分区，挂载到 / # mkfs.fat -F32 /dev/nvme1n1p3 #用作EFI分区 ，挂载到 /boot/efi # 如果安装Windows时已经有个EFI分区，就把上面的/dev/sda1换成已有的EFI分区 mkfs.ext4 /dev/nvme1n1p8 # 挂载到 /home 目录 # mount mount /dev/nvme1n1p7 /mnt #挂载根目录 mkdir -p /mnt/boot/efi #EFI分区的挂载点 mount /dev/nvme1n1p1 /mnt/boot/efi #挂载EFI分区 mount --mkdir /dev/nvme1n1p8 /mnt/home 选择软件镜像仓库 手动修改/etc/pacman.d/mirrorlist vim /etc/pacman.d/mirrorlist --- Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch --- pacman -Sy archlinuxcn-keyring pacman -Syyu 安装基础包 pacstrap /mnt bash base base-devel linux linux-headers linux-firmware neovim xsel // fstab genfstab -U -p /mnt \u003e\u003e /mnt/etc/fstab chroot arch-chroot /mnt # 时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc # hostname vim /etc/hostname --- 键入：`arch` --- # 设置 locale vim /etc/locale.conf --- 键入：`LANG_en_US.UTF-8` --- vim /etc/locale.gen --- 取消注释：`#en_US.UTF-8 UTF-8` 取消注释：`#zh_CN.UTF-8 UTF-8` --- locale-gen # 网络管理器，蓝牙 pacman -S networkmanager bluez bluez-utils pulseaudio-bluetooth alsa-utils pulseaudio pulseaudio-alsa sof-firmware systemctl enable NetworkManager.service systemctl enable bluetooth.service # root password passwd --- 键入密码：xxxxxx --- # ucode cat /proc/cpuinfo | grep \"model name\" pacman -S intel-ucode # amd-ucode # 安装引导加载程序 pacman -S grub efibootmgr os-prober grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB # 配置 os-prober vim /etc/default/grub --- 取消注释:`GRUB_DISABLE_OS_PROBER=false` --- grub-mkconfig -o /boot/grub/grub.cfg # Create user and usergroup useradd -m -G wheel tianen passwd tianen --- 键入密码 --- # 修改权限 pacman -S sudo man-pages man-db vim /etc/sudoers --- 取消注释：`%wheel ALL=(ALL:ALL) ALL` --- su - tianen # KDE sudo pacman -S plasma xorg nvidia dolphin konsole fish noto-fonts-cjk noto-fonts-emoji sudo systemctl enable sddm # reboot exit swapoff /mnt/swapfile umount -R /mnt reboot ","date":"2024-04-17","objectID":"/archlinuxnote/:1:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"一、内核更换 Install The Desired Kernel sudo pacman -S linux-lts linux-lts-headers Editing GRUB Config File sudo vim /etc/default/grub # --- `GRUB_DISABLE_SUBMENU=y` # disables the GRUB submenu, i.e., it enables all the available kernels to be listed on the main GRUB Menu itself instead of the “Advanced option for Arch Linux” option. `GRUB_DEFAULT=saved` # saves the last kernel used `GRUB_SAVEDEFAULT=true` # makes sure that grub uses the last selected kernel is used as default Re-Generate GRUB Configuration file sudo grub-mkconfig -o /boot/grub/grub.cfg Choose Kernel From GRUB During Boot ","date":"2024-04-17","objectID":"/archlinuxnote/:2:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"二、Software ","date":"2024-04-17","objectID":"/archlinuxnote/:3:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Check NetworkManager ping baidu.com systemctl enable NetworkManager ","date":"2024-04-17","objectID":"/archlinuxnote/:3:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"pacman 镜像修改 sudo vim /etc/pacman.conf # ---------------- # Misc options Color ParallelDownloads = 5 # --- [multilib] Include = /etc/pacman.d/mirrorlist #--- 键入： [archlinuxcn] Server = https://mirrors.utsc.edu.cn/archlinuxcn/$arch #--- sudo pacman -Syyu sudo pacman -S archlinuxcn-keyring ","date":"2024-04-17","objectID":"/archlinuxnote/:3:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"常见通用软件 sudo pacman -S yay pacman -Sc # 清除软件缓存，即/var/cache/pacman/pkg目录下的文件 pacman -Rns package_name pacman -U pacage.tar.zx # 从本地文件安装 pactree pacage_name # 显示软件的依赖树 yay -S fish # curl -L https://get.oh-my.fish | fish fish_config # 取消问候语 set -U fish_greeting \"\" sudo vim /etc/systemd/system/clash.service sudo systemctl daemon-reload sudo systemctl enable clash sudo systemctl start clash sudo systemctl status clash sudo pacman -S obs-studio 输入法 sudo pacman -S fcitx5 fcitx5-configtool fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-material-color fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki # sudo vim /etc/environment GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=\\@im=fcitx # 为了让一些使用特定版本 SDL2 库的游戏能正常使用输入法 SDL_IM_MODULE=fcitx yay -S clash-verge-rev-bin yay -Sy neofetch google-chrome obs-studio baidunetdisk nutstore-experimental xunlei-bin telegram-desktop gitkraken visual-studio-code-bin typora-free redis net-tools pot-translation translate-shell okular snipaste gwenview kcalc wemeet-bin vlc wget ark shotcut inkscape ninja gnu-netcat tcpdump cmake clang tree python-pip caj2pdf-qt ttf-hack-nerd transmission-gtk gpick speedcrunch drawio-desktop crow-translate zeal yay -S electronic-wechat-uos-bin linuxqq lx-music-desktop gpick: 可以从桌面任何地方取色，并且它还提供一些其它的高级特性 SpeedCrunch: 一个漂亮，开源，高精度的科学计算器 Snipaste: 截图工具，如不可用可选用spectacle drawio-desktop: Security-first diagramming for teams crow-translate：翻译工具 zeal：离线文档浏览器 office yay -S wps-office wps-office-mui-zh-cn ttf-wps-fonts ","date":"2024-04-17","objectID":"/archlinuxnote/:3:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"远程工具 - Remmina $ yay -S remmina freerdp 使用教程 安装 freerdp 插件后，可以走 RDP 协议远程 Win10（Win10 不需要其他任何设置） ","date":"2024-04-17","objectID":"/archlinuxnote/:3:4","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Git 配置git 设置user.name和user.emal git config --global user.name \"lutianen\" git config --global user.email tianen.xd@gmail.com # check git config --list 生成密钥 ssh-keygen.exe -t rsa -C 'tianen.xd@gmail.com' 上述代码执行完成后，要求多次输入密码，请不要输入密码 github配置 SSH Keys 打开生成的 Key 文件 /.ssh/id_rsa.pub 复制全部内容，在 Key 中粘贴 Git 常用命令 git status git clone git pull git push git commit -m 'commits' or git commit -m 'commits' xxx.fileType git add . or git xxx.fileType git reflog Git实现从本地添加项目到远程仓库 Steps: 创建一个新的远程仓库 - Create a new repo Create repository 创建并初始化本地仓库 - git init 可添加待上传到远程仓库的项目文件 远程仓库和本地仓库关联 - git remote add origin git@github.com:lutianen/System4CE7 项目文件添加、提交、推送 git add file git commit -m 'commit statements' file git push -u origin master *由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 在以后的推送或者拉取时就可以简化命令 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:5","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Golang # Download and install go sudo pacman -S go # Set environment variable in `.config/fish/config.sh` or `/etc/profile` or `~/.profile` GOROOT /usr/lib/go GOPATH /home/tianen/goProj GOBIN /home/tianen/goProj/bin PATH $GOPATH/bin $GOROOT/bin $GOBIN $PATH GOROOT，设置 Golang 的安装位置 GOBIN，执行 go install 后生成可执行文件的目录 GOPATH，工作目录，一般设置到用户目录下 # Go 工作目录结构 ├── bin # 存放 `go install` 命令生成的可执行文件，且可把 `$GOBIN` 路径加入到 `PATH` 环境变量中，这样就可以直接在终端中使用 go 开发生成的程序 ├── pkg # 存放 go 编译生成的文件 ├── readme.md └── src # 存放 go 源码，不同工程项目的代码以包名区分 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:6","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"MySQL 很多linux发行版都放弃了对mysql的支持（原因自行百度）转而支持mariadb（mysql的另一个分支），Archlinux就是其中之一，mariadb具有和mysql一模一样的操作命令，所以完全不用考虑迁移兼容的问题 安装mariadb: sudo pacman -Sy mariadb 配置mariadb命令，创建数据库都在/var/lib/mysql/目录下面: sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 开启mariadb 服务: systemctl start mariadb 初始化密码，期间有让你设置密码的选项，设置你自己的密码就行了，然后根据自己理解y/n就可，因为很多后面可以再修改: sudo /usr/bin/mysql_secure_installation 登录mariadb 和mysql命令是一样的: mysql -u root -p 设置开机自启动服务: systemctl enable mariadb #开机自启动 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:7","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"you-get 命令行程序，提供便利的方式来下载网络上的媒体信息。 yay -S you-get 下载流行网站之音视频，例如YouTube, Youku, Niconico,以及更多 于您心仪的媒体播放器中观看在线视频，脱离浏览器与广告 下载您喜欢的网页上的图片 下载任何非HTML内容，例如二进制文件 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:8","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"挂载其他硬盘分区 # Get UUID and TYPE sudo blkid # /dev/nvme1n1p3: LABEL=\"Document\" BLOCK_SIZE=\"512\" UUID=\"111915F1111915F1\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"666266ba-233b-11ed-95be-00e04c3656eb\" # Write UUID TYPE ... sudo vim /etc/fstab # \u003cdevice\u003e \u003cdir\u003e \u003ctype\u003e \u003coptions\u003e \u003cdump\u003e \u003cfsck\u003e UUID=111915F1111915F1 /home/tianen/doc ntfs3 defaults 0 0 \u003cdevice\u003e 描述要挂载的特定块设备或远程文件系统 \u003cdir\u003e 描述挂载目录 \u003ctype\u003e 文件系统类型 \u003coptions\u003e 相关的挂载选项 \u003cdump\u003e 会被 dump(8) 工具检查。该字段通常设置为 0, 以禁用检查 \u003cfsck\u003e 设置引导时文件系统检查的顺序; 对于 root 设备该字段应该设置为 1。对于其它分区该字段应该设置为 2,或设置为 0 以禁用检查 我使用 TYPE 为 ntfs 时导致启动失败，修改为 ntfs3 后成功挂载 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:9","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Present Windows ","date":"2024-04-17","objectID":"/archlinuxnote/:3:10","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"scp 文件上传、下载 上传 scp .\\cifar-10-python.tar.gz lutianen@10.xxx.xxx.xxx:/home/lutianen/ 下载 scp root@10.xxx.xxx.xxx:/var/tmp/a.txt /var ","date":"2024-04-17","objectID":"/archlinuxnote/:3:11","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"picgo picgo-core 【Recommend】 Download and Install PigGo-Core Get token with GitHub Configure config.json NOTE：When using ~/.picgo/config.json, delete the comments to avoid unnecessary trouble（使用时，将注释删掉，以免产生不必要的麻烦） { \"picBed\": { \"current\": \"github\", \"github\": { \"repo\": \"lutianen/PicBed\", // 设定仓库名：上文在 GitHub 创建的仓库 `lutianen/PicBed` \"branch\": \"master\", // 设定分支名：`master` \"token\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // 设定 Token：上文生成的 toke \"path\": \"\", // 指定存储路径：为空的话会上传到根目录，也可以指定路径 \"customUrl\": \"\" // 设定自定义域名：可以为空 }, \"uploader\": \"github\", \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true } } picgo app 【Not Recommend】 安装 picgo: yay -S picgo picgo 配置 github github 获取 token: 见 picgo-core 配置 PicGo 配置 设定仓库名：上文在 GitHub 创建的仓库 lutianen/PicBed 设定分支名：master 设定 Token：上文生成的 token 指定存储路径：为空的话会上传到跟目录，也可以指定路径 设定自定义域名：可以为空，这里为了使用 CDN 加快图片的访问速度，按这样格式填写：https://cdn.jsdelivr.net/gh/lutianen/PicBed/@master ","date":"2024-04-17","objectID":"/archlinuxnote/:3:12","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"VirtualBox sudo pacman -S virtualbox # dkms sudo pacman -S virtualbox-host-dkms sudo dkms autoinstall sudo modprobe vboxdrv sudo pacman -S virtualbox-guest-utils sudo systemctl enable vboxservice.service ","date":"2024-04-17","objectID":"/archlinuxnote/:3:13","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"CUDA \u0026 cuDNN yay -S cuda-11.7 cudnn8-cuda11.0 Arch Linux 会将 CUDA 相关档案安装至 /opt/cuda，有需要的话可以将 CUDA 的 PATH 加到 ~/bashrc，此路径永远指向最新版CUDA # cuda # fish set PATH /opt/cuda-11.7/bin $PATH set LD_LIBRARY_PATH /opt/cuda-11.7/lib64/ $PATH pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu117 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:14","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"wireguard # Install wg sudo pacman -S wireguard-tools # Open wg sudo wg-quick up wg0 # Close wg sudo wg-quick down wg0 wg0.conf /etc/wireguard/wg0.conf [Interface] PrivateKey = xxxxxxxxxxxxxxxxxxx Address = 172.16.0.2/32 Address = 2606:4700:110:8fe8:bc78:d25a:896a:9696/128 DNS = 1.1.1.1 MTU = 1280 [Peer] PublicKey = bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo= AllowedIPs = 0.0.0.0/0 AllowedIPs = ::/0 Endpoint = xxx.xxx.xxx.xxx 配置步骤如下 # Error: /usr/bin/wg-quick: line 32: resolvconf: command not found sudo pacman -S openresolv WARP 密钥获取：Telegram 中 Warp+ Bot 获取 2.配置文件生成：https://replit.com/@misaka-blog/wgcf-profile-generator?v=1 https://replit.com/@tianenxd/wgcf-profile-generator，需要登陆 3.优选IP ==warp-yxip== wget -N https://gitlab.com/Misaka-blog/warp-script/-/raw/main/files/warp-yxip/warp-yxip.sh \u0026\u0026 bash warp-yxip.sh ","date":"2024-04-17","objectID":"/archlinuxnote/:3:15","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Clash Verge 解决DNS泄露问题 DNS 泄露其实并没有一个明确的定义，也不存在一个官方解释。 大概就是说你访问YouTube等黑名单网站的时候，使用中国大陆的DNS服务器进行了解析，这可能导致隐私问题的。 如果在 DNS Leak Test 、ipleak这种网站的列表中看到了中国国旗，就要意识到可能发生了DNS泄露。 虽然没有人知道具体的探测机制是什么，但很可能是从网络层面获取的。在一般的家庭网络拓扑中，wireshark可以看到什么内容，运营商就能看见什么内容，所以你使用114.114.114.114、223.5.5.5这样的DNS解析去访问了什么网站是很清晰的。 Clash开启TUN模式，关闭系统代理去使用：与普通的系统代理模式区别在于，TUN模式下Clash会创建一张虚拟网卡，从网络层面接管所有的网络流量。 Step 1: 开启TUN模式 Step 2: 使用稳定的DNS DNS这部分有人会教使用运营商的DNS，运营商的DNS只适合小白用户，因为他可能连反诈，所以建议使用国内大厂的。 关闭浏览器的QUIC, 中国大陆的isp是限速udp的, 所以导致QUIC这个优秀的协议, 到了中国大陆的网络下成了个负面增益效果。 about://flags/#enable-quic 设置为Disabled (点下方弹出的重启浏览器生效) 关闭浏览器中的“安全DNS” chrome://settings/security 在Clash Verge的【Profiles】中，点右上角的\"NEW\" -\u003e Type选择\"Script\" -\u003e Name随意填写(例如，“修改DNS”) 右击新建的文件，然后\"Edit File\"，输入以下内容后启用： function main(content) { const isObject = (value) =\u003e { return value !== null \u0026\u0026 typeof value === 'object' } const mergeConfig = (existingConfig, newConfig) =\u003e { if (!isObject(existingConfig)) { existingConfig = {} } if (!isObject(newConfig)) { return existingConfig } return { ...existingConfig, ...newConfig } } const cnDnsList = [ 'tls://223.5.5.5', 'tls://1.12.12.12', ] const trustDnsList = [ 'https://doh.apad.pro/dns-query', 'https://dns.cooluc.com/dns-query', 'https://1.0.0.1/dns-query', ] const notionDns = 'tls://dns.jerryw.cn' const notionUrls = [ 'http-inputs-notion.splunkcloud.com', '+.notion-static.com', '+.notion.com', '+.notion.new', '+.notion.site', '+.notion.so', ] const combinedUrls = notionUrls.join(','); const dnsOptions = { 'enable': true, 'default-nameserver': cnDnsList, // 用于解析DNS服务器 的域名, 必须为IP, 可为加密DNS 'nameserver-policy': { [combinedUrls]: notionDns, 'geosite:geolocation-!cn': trustDnsList, }, 'nameserver': trustDnsList, // 默认的域名解析服务器, 如不配置fallback/proxy-server-nameserver, 则所有域名都由nameserver解析 } // GitHub加速前缀 const githubPrefix = 'https://ghproxy.lainbo.com/' // GEO数据GitHub资源原始下载地址 const rawGeoxURLs = { geoip: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geoip-lite.dat', geosite: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geosite.dat', mmdb: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/country-lite.mmdb', } // 生成带有加速前缀的GEO数据资源对象 const accelURLs = Object.fromEntries( Object.entries(rawGeoxURLs).map(([key, githubUrl]) =\u003e [key, `${githubPrefix}${githubUrl}`]), ) const otherOptions = { 'unified-delay': true, 'tcp-concurrent': true, 'profile': { 'store-selected': true, 'store-fake-ip': true, }, 'sniffer': { enable: true, sniff: { TLS: { ports: [443, 8443], }, HTTP: { 'ports': [80, '8080-8880'], 'override-destination': true, }, }, }, 'geodata-mode': true, 'geox-url': accelURLs, } content.dns = mergeConfig(content.dns, dnsOptions) return { ...content, ...otherOptions } } 设置完成后，验证DNS解析结果是否都是来自国外的Cloudflare和Google的DNS, 这时节点服务器不管拿到了你传过去的真ip还是假ip地址, 他都会再去请求一次Cloudflare/Google的DNS服务, 确保解析的正确性。 重要的是没有中国大陆的DNS服务器了，如果还是有，那你应该往当前设备的更上层寻找问题所在，比如路由器的设置等。 Clash Verge 解决 GEOIP，CN问题 目前市面上绝大多数的代理工具都依赖于 GeoIP2 数据库判断地址所属地。它们的规则结尾部分一般都会有一条类似 GEOIP, CN，用来查询目的 IP 地址是否属于中国大陆，从而判断是否直连。 这些代理工具通常使用的 GeoIP2 数据库是来自于 MaxMind 的 GeoLite2 免费数据库。这个数据库目前存在一下几个问题： 获取不便：从 2019 年 12 月 30 日起，必须注册后才能下载 数据量大：数据库庞大，包含全球的 IP 地址段，约 10 MB 准确度低：对中国大陆的 IP 地址判定不准，如：香港阿里云的 IP 被判定为新加坡、中国大陆等。 庞大的数据量对于大多数中国大陆的用户来说是没有意义的，因为只仅需要去判断 IP 的地理位置是否属于中国大陆境内，其他国家的 IP 一律代理/直连。过多的数据量会增加载入时间，降低查询效率。 我们在之前创建的Script中已经包含了下载更精简合适中国大陆的IP数据库链接, 现在只需要手动操作下载和替换即可: Update GeoData: Clash Verge Rev的设置菜单中点击Update GeoData 验证下载: 打开Clash Verge托盘中的APP Dir，找到geoip.dat文件，验证其大小是否为几百KB 重启Clash Verge：确保数据库被正确应用 ","date":"2024-04-17","objectID":"/archlinuxnote/:3:16","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"三、System optimization ","date":"2024-04-17","objectID":"/archlinuxnote/:4:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"SSD 优化 TRIM, 会帮助清理SSD中的块，从而延长SSD的使用寿命 sudo systemctl enable fstrim.timer sudo systemctl start fstrim.timer ","date":"2024-04-17","objectID":"/archlinuxnote/:4:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"SWAP 设置 https://wiki.archlinux.org/title/Swap#Swappiness 查看 swap 使用率，一般是 60 ，意思是 60% 的概率将内存整理到 swap: cat /proc/sys/vm/swappiness 修改 swap 使用策略为 10%，即 10% 的概率将内存整理到 swap: sudo sysctl -w vm.swappiness=10 修改配置文件：sudo vim /etc/sysctl.d/99-swappiness.conf 在文件末尾加上下面这行内容：vm.swappiness=10 重启后可查看 swappiness 的值 ","date":"2024-04-17","objectID":"/archlinuxnote/:4:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"Systemd journal size limit 控制日志最大可使用多少磁盘空间，修改/etc/systemd/journald.conf 中的SystemMaxUse参数 SystemMaxUse=50M ","date":"2024-04-17","objectID":"/archlinuxnote/:4:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"四、Games sdl-ball: yay -S sdl-ball ","date":"2024-04-17","objectID":"/archlinuxnote/:5:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"五、Problem And Solution ","date":"2024-04-17","objectID":"/archlinuxnote/:6:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"1. clear command - terminals database is inaccessible 解决方案：Path for Anaconda3 is set in .bashrc. It is interfering with the clear command. Removing Anaconda path from path solved the issue. ~ echo $CONDA_PREFIX (base) /opt/miniconda sudo mv $CONDA_PREFIX/bin/clear $CONDA_PREFIX/bin/clear_old ","date":"2024-04-17","objectID":"/archlinuxnote/:6:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"2. tput: unknown terminal \"xterm-256color\" 解决方案：setenv TERMINFO /usr/lib/terminfowps ","date":"2024-04-17","objectID":"/archlinuxnote/:6:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"3. 更新内核后，双屏显示时，某一个屏幕黑屏，但鼠标能够移动过去并显示，另一屏幕正常 解决方案：xrandr --output HDMI-1-0 --right-of eDP1 --auto 命令解释：配置 HDMI-1-0 输出，使其位于 eDP1 输出的右侧，并自动选择最佳的分辨率和刷新率设置 $ xrandr --listmonitors Monitors: 2 0: +*eDP1 2560/360x1440/200+0+0 eDP1 1: +HDMI-1-0 1920/479x1080/260+2560+0 HDMI-1-0 $ xrandr --output HDMI-1-0 --right-of eDP1 --auto ","date":"2024-04-17","objectID":"/archlinuxnote/:6:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"4. zip 压缩包解压乱码 产生这种情况的原因是，zip 格式本身的缺陷导致的：**zip 格式没有指定文件名的编码格式，因此在压缩和解压时都会采用OS本地编码，而 Window 下简体中文采用的是 GBK/GB312 编码，Linux 则采用的是 UTF-8 编码，两者不一致导致了乱码的产生。 解决方案: unzip -O GBK xxx.zip ","date":"2024-04-17","objectID":"/archlinuxnote/:6:4","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"5. wps-office大部分字体粗体出现过粗无法正常显示问题 问题: freetype2更新至2.13.0以上版本后出现的问题。导致wps-office 文档编辑文字大部分字体设置粗体出现过粗无法正常显示。 解决方案：freetype2 降级至 2.13.0 Downloadfreetype2.13.0 降级 sudo pacman -U freetype2-2.13.0-1-x86_64.pkg.tar.zst 修改 /etc/pacman.conf -\u003e IgnorePkg = freetype2，排除掉这个包（不让它更新） freetype2: ignoring package upgrade (2.13.0-1 =\u003e 2.13.2-1) env LD_LIBRARY_PATH=/usr/local/freetype2-2.13.0-1-x86_64/usr/lib `update-desktop-database ~/.local/share/applications ","date":"2024-04-17","objectID":"/archlinuxnote/:6:5","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"6. wpspdf 无法打开 PDF 文件 wpspdf 依赖于 libtiff5.so.5 以支撑其 PDF 功能。而系统更新后，Arch Linux 提供的是 libtiff.so.6 或更新版本，导致其无法正常工作。 解决方案：安装 libtiff5 ","date":"2024-04-17","objectID":"/archlinuxnote/:6:6","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"7. WPS 无法输入中文 解决方案 wpp wpspdf wpp et ","date":"2024-04-17","objectID":"/archlinuxnote/:6:7","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"8. lx-music 数据同步失败 确保PC端的同步服务已启用成功: 若连接码、同步服务地址没有内容，则证明服务启动失败，此时看启用同步功能复选框后面的错误信息自行解决 在手机浏览器地址栏输入http://x.x.x.x:5963/hello后回车，若此地址可以打开并显示 Hello~::^-^::~v4~，则证明移动端与PC端网络已互通， 若移动端无法打开第2步的地址，则在PC端的浏览器地址栏输入并打开该地址，若可以打开，则可能性如下： LX Music PC端被电脑防火墙拦截 PC端与移动端不在同一个网络下， 路由器开启了AP隔离（一般在公共网络下会出现这种情况） 要验证双方是否在同一个网络或是否开启AP隔离，可以在电脑打开cmd使用ping命令ping移动端显示的ip地址，若可以通则说明网络正常 ","date":"2024-04-17","objectID":"/archlinuxnote/:6:8","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"9. fatal: unable to access 'https://github.com/xxxxxxx.git/': Failed to connect to github.com port 443: Timed out 问题：代理出问题 解决方案： git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2024-04-17","objectID":"/archlinuxnote/:6:9","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Linux","Software"],"content":"10. fatal: unable to access 'https://github.com/xxxx.git/': gnutls_handshake() failed: The TLS connection was non-properly terminated. 解决方案： git config --global http.sslVerify false ","date":"2024-04-17","objectID":"/archlinuxnote/:6:10","tags":["Arch","Linux","Software"],"title":"Arch Linux 使用指南","uri":"/archlinuxnote/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"借助于 Github Pages 提供的静态网站托管服务，并采用了 Hugo 这一开源项目，加快了建站流程，而且有多种开源网站主题可供选择.","date":"2024-04-17","objectID":"/build-blog/","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"借助于 Github Pages 提供的静态网站托管服务，并采用了 Hugo 这一开源项目，加快了建站流程，而且有多种开源网站主题可供选择. ","date":"2024-04-17","objectID":"/build-blog/:0:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"I. 前言 在博客网站搭建完成之后，有充分的理由相信，自己在未来很长一段时间内将不会再次重复建站。 常言道天有不测风云，为了防止各种意外情况发生，导致本博客网站无法正常使用，同时防止自己忘记搭建流程，故记录于此。 ","date":"2024-04-17","objectID":"/build-blog/:1:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"II. 效果 ","date":"2024-04-17","objectID":"/build-blog/:2:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"III. 相关知识简介 ","date":"2024-04-17","objectID":"/build-blog/:3:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Github Pages GitHub Pages 是一个免费的静态网站托管服务，它允许用户通过 GitHub 存储库来托管和发布网页，可以使用它来展示项目文档、博客或个人简历。 现阶段，Github Pages 支持公共存储库的免费的托管；对于私有仓库，需要进行缴费。 ","date":"2024-04-17","objectID":"/build-blog/:3:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Hugo 官方号称，Hugo 是世界上最快的网站建设框架(The world’s fastest framework for building websites)。 ","date":"2024-04-17","objectID":"/build-blog/:3:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"IV. Steps ","date":"2024-04-17","objectID":"/build-blog/:4:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Github 仓库创建 需要创建两个仓库，一个用于网站源码管理(sA)，一个用于网站部署(sB): sA 可以是 public，也可以是 private； sB 仓库的名称必须是 username.github.io（username 是 Github Accout 中username，不是 profile 中的 Name），同时还需要添加 README.md； ","date":"2024-04-17","objectID":"/build-blog/:4:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"使用 Hugo 创建网站 首先，使用 Git 将 sA 拉取下来: ~/ $ git clone https://github.com/lutianen/Kyden-blog.git 然后，进入本地的 sA 目录（即，Kyden-blog）下，使用 hugo 建站： # Linux: Install ~/Kyden-blog $ sudo pacman -S hugo ~/Kyden-blog $ hugo version # 建站，然后将生成的内容复制到 `sA` 仓库中 ~/Kyden-blog $ hugo new Kyden-blog ~/Kyden-blog $ mv Kyden-blog/ . ~/Kyden-blog $ rm Kyden-blog -rf ","date":"2024-04-17","objectID":"/build-blog/:4:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Hugo 设置网站主题 可以从 Hugo Themes 挑选合适的主题进行应用： ~/Kyden-blog $ cd themes ~/Kyden-blog/themes $ git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git tranquilpeak 安装 Hugo 主题后，根据个人情况修改相应的配置文件即可； ","date":"2024-04-17","objectID":"/build-blog/:4:3","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"文章管理 启动 Hugo server 启动本地 server： ~/Kyden-blog $ hugo server -D 浏览器打开 http://localhost:1313/ 进行预览； 新建文章 ~/Kyden-blog $ hugo new content `post/Golang/Go.md` # `post/Golang/Go.md` 表明 markdown 的路径 部署文章 构建 Hugo 网站相关静态文件 Hugo 将构建完成的静态内容保存到 sA 仓库中的 public 文件夹中； ~/Kyden-blog $ hugo 部署 进入 public 目录，利用 Git 进行管理该文件夹，并推送到远程 sB 仓库中： ~/Kyden-blog/public $ git init ~/Kyden-blog/public $ git commit -m \"first commit\" ~/Kyden-blog/public $ git branch -M master ~/Kyden-blog/public $ git remote add origin https://github.com/lutianen/lutianen.github.io.git ~/Kyden-blog/public $ git push -u origin master 自动化部署：deploy.sh #!/bin/bash echo -e \"\\033[0;32mDeploying updates to GitHub...\\033[0m\" # Build the project. hugo # if using a theme, replace with hugo -t # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site `date` \" echo -e \"\\033[0;32m$msg\\033[0m\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. 删除文章 进入 Kyden-blog/post/ 目录中，删除，目标文件夹（包含相关文章资源）即可； NOTE：Kyden-blog/public 中相关文件可以删除，也可以不删除，推荐删除； ","date":"2024-04-17","objectID":"/build-blog/:4:4","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Google Analytics（分析） 首先，在 GA 网站中注册、设置完成相应选项，即可获取 ID：G-XXXXXXXXXX； 然后在 layout/_default/baseof.html 文件中添加以下代码即可： \u003c!-- Google tag (gtag.js) --\u003e \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"\u003e\u003c/script\u003e \u003cscript\u003e window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX'); \u003c/script\u003e 该段代码获取方法如下：Google Analytics（分析） -\u003e 管理 -\u003e “媒体资源设置\"列中的数据流 -\u003e 网站 -\u003e 对应的数据流 -\u003e “Google 代码” 下的查看代码说明 -\u003e “安装说明” 选择手动添加 建议添加完成后，在GA分析中进行测试，确保生效 ","date":"2024-04-17","objectID":"/build-blog/:4:5","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"评论系统 - Gitalk 需要注意的是，Gitalk 的评论采用的是 PR/Issue 的方式存储评论，因此，一般需要新建一个专门的 Repo，例如username/gitalk. 申请注册新应用，并填写以下相关内容： Application name: 随意 Homepage URL: 包含 http/https 前缀，例如https://lutianen.github.io Authorization callback URL: 和上面 Homepage URL 保持一致就行 注册完成后，手动生成 Client secrets(只会出现一次)，同时获得 Client ID. 最后，在主题设置中填写相应信息即可，例如 LoveIt 中的 config.toml: [params.page.comment] enable = true [params.page.comment.gitalk] enable = true owner = \"lutianen\" repo = \"gitalk\" clientId = \"xxxxxxxxxxxxxxxxxxxx\" clientSecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" ","date":"2024-04-17","objectID":"/build-blog/:4:6","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"网站运行时间统计 在 footer.html 加入以下内容即可： {{- /* runtime */ -}} \u003c/br\u003e\u003cscript\u003e function siteTime() { var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var startYear = 2024; var startMonth = 4; var startDate = 18; var startHour = 12; var startMinute = 57; var startSecond = 2; var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond); var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); if (startYear == todayYear) { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } else { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffYears + \" 年 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } } setInterval(siteTime, 1000); \u003c/script\u003e \u003cspan id=\"sitetime\"\u003e载入运行时间...\u003c/span\u003e ","date":"2024-04-17","objectID":"/build-blog/:4:7","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"V. Problem And Solution ","date":"2024-04-17","objectID":"/build-blog/:5:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"添加图片不显示 Hugo 的配置文件和文章中的引用图片都是以 static 作为根目录，因此图片无法显示的解决方案如下： 将图片放入 static/img 目录下 在文章中的图片引用方式为：/img/xxx.png 无法采用 Typora 等软件进行预览，需要在网页中进行预览: http://localhost:1313/ ","date":"2024-04-17","objectID":"/build-blog/:5:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"文章缩略 如果想要文章在某个地方缩略，只需要在该位置加入 \u003c!--more--\u003e 即可。 ","date":"2024-04-17","objectID":"/build-blog/:5:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"VI. References Abot Github Pages Hugo 参考文章 Gitalk 评论系统安装 ","date":"2024-04-17","objectID":"/build-blog/:6:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"GitHub Pages + Hugo 建博客站","uri":"/build-blog/"}]